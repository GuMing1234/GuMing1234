# 基本概念
### 核心思想
* 局部最优以达到整体最优。
* 缺点：有时候局部最优会变成整体不优，因此这时候要使用动态规划
**因此我们要在不同的情形下使用不用的方法**
### 例题一：
[P2240 【深基12.例1】部分背包问题 - 洛谷](https://www.luogu.com.cn/problem/P2240#ide)
**解析：这道题是经典的贪心思想，其与背包模型的不同是这里面的物品是可以拆分的**
遇到这种可拆分的题目我们就可以使用贪心思路，用局部最优以达成整体最优。
*代码实现：*
```cpp
#include<bits/stdc++.h>
using namespace std;
int wight[105];
int value[105];
float price[105];
void quick_sort(int left,int right){
    if(left>=right) return ;
    int i=left;
    int j=right;
    int mid=(left+right)/2;
    float p=price[mid];
    while(i<=j){
        while(price[i]<p) i++;
        while(price[j]>p) j--;
        if(i<=j){
        swap(price[i],price[j]);
        swap(wight[i],wight[j]);
        swap(value[i],value[j]);
        i++;
        j--;
        }
    }
    if(left<j) quick_sort(left,j);
    if(right>i) quick_sort(i,right);
}
int main(){
    int n,T;
    cin>>n>>T;
    for(int i=0;i<n;i++){ 
        cin>>wight[i]>>value[i];
        price[i]=value[i]*1.0/wight[i];
    }
    quick_sort(0,n-1);
    int total_wight=0;
    float total_value=0;
    for(int i=n-1;i>=0;i--){
        if(total_wight+wight[i]<=T){
            total_value+=value[i];
            total_wight+=wight[i];
        }
        else{
            int leave_wight=T-total_wight;
            total_value+=leave_wight*price[i];
            break;
        }
    }
    cout<<fixed<<setprecision(2)<<total_value<<endl;
    return 0;
}
```
**解析：**
1. 在这道题里面，我们将每个物品的重量和价值进行拆分，由于每个物品都能无限拆分，因此我们可以用贪心算法，如果不能拆分我们只能用动态规划。
2. 先计算每个物品的性价比，按照性价比进行排序，现将性价比最高的装进去，很轻松就能知道，我们这样就能得到总价值最高的组合。
### 例题二：
[P5019 [NOIP 2018 提高组] 铺设道路 - 洛谷](https://www.luogu.com.cn/problem/P5019#ide 
**解析：本题的贪心思路很好理解，但解决问题的方式十分巧妙。**
*代码实现：*
```cpp
#include<bits/stdc++.h>
using namespace std;
long long num=0;
int a[100005];
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    num=a[0];
    for(int i=1;i<n;i++){
        if(a[i-1]<a[i]) num+=a[i]-a[i-1];
    }
    cout<<num<<endl;
    return 0;
}
```
**解析：** 
1. 本题我们的思路主要是递推。
2. 我们可以进行如下假设，我们设置两个相邻的位置，i 与 i-1， 设f( i )为当路的长度为i的时候我们铺设的次数。
3. 对于f( i )来说，如果i =1 ,f[1] 为a[ 1 ]，对于 i 来说，如果a[i-1]>=a[i],那么当铺路的时候，第i个位置的坑一定会在第i-1填满前被填满，因此f[i]=f[i-1]
4. 如果a[i-1]<a[i]，这个时候我们填满a[i-1]后，a[i],还没被填满，这个时候我们就需要，再填第i个位置，因为 i-1 被填满了，因此第 i 的坑的深度为a[i]-a[i-1]，因此这是的总数量就是 f[i]=f[i-1]+(a[i]-a[i-1])
5. 按这样的规律递推下去，就能得到最后我们需要填坑的总时间。