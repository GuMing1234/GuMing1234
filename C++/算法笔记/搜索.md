## 基础知识
1. 搜索分为深度优先搜索（dfs）和广度优先搜索（bfs），二者适用的范围不一样。
2. 深搜通常用于找所有可能的路径，即寻找所有情况，时间复杂度较大。当可能性不太多的时候，可以使用。
3. 广搜适用于寻找最短路径，当可能性较多的时候，可以用广搜来寻找最短路径。
### 例题一：迷宫
[P1605 迷宫 - 洛谷](https://www.luogu.com.cn/problem/P1605#ide)
*代码实现：*
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,t;
int sx,sy,fx,fy;
int k[12][12];
int num;
bool vit[12][12]={false};
void search(int x,int y){
	if(x<=0||x>n||y<=0||y>m) return;
	if(k[x][y]==1||vit[x][y]) return; //要标记是否访问过。 
	if(x==fx&&y==fy){
		num++;
		return ;
	}
	vit[x][y]=true;
	search(x+1,y);
	search(x,y+1);
	search(x-1,y);
	search(x,y-1);
	vit[x][y]=false;
}

int main(){
	cin>>n>>m>>t; 
	cin>>sx>>sy>>fx>>fy;
	int tem1,tem2;
	for(int i=0;i<t;i++){
		cin>>tem1>>tem2;
		k[tem1][tem2]=1;
	}
	search(sx,sy);
	cout<<num;
    return 0;
}
```
**解析：**
1. 本题使用了深度优先搜索寻找了所有可能的路径。
2. 搜索本质上也是递归，因此也要有终止条件，但搜索比递归多出来的是还原条件这个一部分。
3. 本题的终止条件就是我们的路径到达了重点。
4. 遇到障碍物我们要退出这次查找，同时我们经过的路径也要避开，可以单独定义一个路径数组，也可以直接将路径变为障碍物，这样就可以达到相同的效果但省略一些代码。
5. 本题的回溯状态就是在递归的后面将我们的路径变为未经过。

### 例题二： 八皇后 Checker Challenge
[P1219 [USACO1.5] 八皇后 Checker Challenge - 洛谷](https://www.luogu.com.cn/problem/P1219)
*代码实现：*
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[15][15];
int num=0;
int n;
int res[4][15];
bool judge(int x,int y){
    for(int i=1;i<x;i++){
        if(a[i][y]==1) return false;
        }
    for(int i=x-1,j=y-1;i>=1&&j>=1;i--,j--){
    	if(a[i][j]==1) return false;
	}
	for(int i=x-1,j=y+1;i>=1&&j<=n;i--,j++){
    	if(a[i][j]==1) return false;
	}
	return true;
}

void search(int x,int mark){
    if(mark==n){
        num++;
        if(num<=3){
            for(int i=1;i<=n;i++){
                for(int j=1;j<=n;j++){
                    if(a[i][j]==1){
                    	res[num][i]=j;
                    	break;
					}
                }
            }
        }
        return ;
    }
    for(int i=1;i<=n;i++){
        if(judge(x,i)){
            a[x][i]=1;  
            search(x+1,mark+1);
            a[x][i]=0; //回溯状态； 
        }
    }
    return ;
}
int main(){
    cin>>n;
    search(1,0);
    for(int i=1;i<=3;i++){
        for(int j=1;j<=n;j++) cout<<res[i][j]<<" ";
        cout<<"\n";
    }
    cout<<num;
    return 0;
}
```
**解析：**
1. 本题大致思路就是从第一排开始，每排都有且仅有一个皇后，我们将每排的皇后都找出来。
2. 本题里面我们是一排一排找的，因此查找是要遍历这一排每个位置，然后对时候合法进行判断。
3. 终止条件就是我们找到了最后一排的皇后在找完这个皇后之后要对条件进行回溯。