# 基本概念
### 核心思想：
- 用已知内容算未知内容（如经典爬楼梯问题）
### 术语
- 状态：dp(x)：x个1相加
- 转移方程：dp(x)=dp(x-1)+1
#### 以一道经典题为例：最长上升子序列
**问题：给定一个整数序列，求改序列的最长上升子序列的长度**
状态：dpi代表以i号位置为结尾的最长上升子序列的长度
转移：dpi=max(dpj)+1， 满足j<i,且aj<ai.
代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[20];
int main()
{
	int dp[20]; 
	for(int i=0;i<20;i++){
		dp[i]=1;
	}     
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++){
		int dp_max=0;
		for(int j=1;j<i;j++){
			if(a[j]<a[i]){  //筛选了能不能转移 
				if(dp_max<dp[j]) dp_max=dp[k];
				dp[i]=dp_max+1;
			}
		}
	}
	int dp_max=0;
	for(int k=1;k<=n;k++){
		if(dp_max<dp[k]) dp_max=dp[k];
	}
	cout<<dp_max;
	return 0;
}
```
  以下是我在代码中犯的错：
  - 没有初始化dp的值为1
  - 比较的时候没有比较清楚，没有正确找到dp[j]的最大值，要注意，在每次j的循环里面，我们都要进行一个比较，看哪一个j为结尾的序列拼到i前面最大。 
**以下是二分优化版本**
*理解方式* 从值域的角度理解
***性质
- 定义f(i)为长度为i的子序列中可能的最小结尾值
- 性质一：f数组一定是严格递增的
- 性质二：f数组每次新增一个ai到末尾时，f不会有大范围的数值更新，最多只有一个位置被更新，但不一定在最后面
**分析：
- 这是一个动态的过程，每加进来一个ai，都会有可能会更新一个值，添加的机制为，当ai<f(j),且ai>f(j-1)，只有这时候添加ai是有意义的，这就是二分优化，当ai>f(j-1)的时候，符合单调的原则，当ai<f(j)的时候，添加ai替换f（j）才有意义，能够减少许多无意义的循环  
*代码实现* :
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1002],f[1003]; 
int main()
{
	 //值域视角
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=0;i<=1002;i++) f[i]=1000000002;
	f[0]=-1;
	for(int i=1;i<=n;i++){
		for(int j=i;j>=0;j--){
			if(f[j]>a[i]&&a[i]>f[j-1]) {
				f[j]=a[i];
				break;
			}
		}
	}
	for(int i=1002;i>=0;i--) {
		if(f[i]!=1000000002) {
			cout<<i;
			break;
		}
	}
	return 0;
}
```
 **解析一下此题** ：本题的思路就是二分优化的思想每次加进来一个数，就从中间去找他能放的位置，如果没有符合条件的位置，就不会将其加入，最后找到最后一个数，其位置，跟据定义，第i个位置的数字代表的是长度为i的子序列后一个数字的大小，因此第i个数的位置，就是我们需要的最长的子序列。
 *求序列组合* 当我们找到最后一个f的值之后，从这个数开始，到第一个数，一旦有小于上一个数的值就加到answer数组里面，最后这个数组就是答案。
### 背包模型
**基础概念**：
每个问题都能够被拆分为更小的问题，有点类似递归；但不用递归也可以解决。
***精髓：*** 
1. 如果能放进去，剩余空间为0，则结果=未放进去之前的方法+1
2. 如果能放进去，剩余空间不为0，则结果=未放进去之前的方法数+剩余空间方法数
3. 不能放进去，则结果=未放进去之前的方法数
**以一道小题为例**：整数拆分问题(*完全背包模型*)
*题目描述*：给定一个整数n，请问可以拆分为的整数之和的方案有多少个。
*思路*：在此题里面，我们就可以套用背包模板,设状态为：dp(i，j)，为只能使用前i个数去凑成整数j的方案数
转移：dp(i，j)=dp(i，j-i)+dp(i-1，j)。
如何理解这个转移方式呢？首先我们如果选了i，方法数就是dp(i，j-i)，总数少了i个，如果不选i，就相当于从i-1个数里面去选j的数。这样就完成了对于问题的拆分
*代码实现*：
```cpp
//完全背包：整数拆分
#include<bits/stdc++.h>
using namespace std;
long long dp[10000][10000]={0};
int main(){
    int n;
    cin>>n; //求dp(n，n)
    dp[0][0]=1;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=n;j++){
            if(j==0) dp[i][0]=1;
            else if(j>=i){
                dp[i][j]=dp[i-1][j]+dp[i][j-i];
            }
            else{
                dp[i][j]=dp[i-1][j];
            }
        }
    }
    cout<<dp[n][n];
    return 0;
}
```
**解释**：此代码的目的是求整数之和，放到背包模型里面就是完全背包模型，因此我们可以采用逐行求解的方式，将dp(n，n)求解出来，整体思路为上述所示，这里就不过多赘述了
***优化方法1：*** 滚动数组优化(空间优化)
*思路方法*：本质上dp(i，j)只和第i行和第i-1行有关，与其他的行是没有关系的，就像一个2 * n的窗口来滑动，因此我们可以只设置两行来不断迭代算完一行就将其放到第一行，这样能够节省空间。
*代码实现：*
```cpp
//完全背包：整数拆分
#include<bits/stdc++.h>
using namespace std;
long long dp[2][10000]={0};
int main(){
	int n;
	cin>>n; //求dp(n，n) 
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=n;j++){
			if(j==0) dp[1][0]=1;
			else if(j>=i){
				dp[1][j]=dp[0][j]+dp[1][j-i];
			}
			else{
				dp[1][j]=dp[0][j];
			}
	}
		for(int j=0;j<=n;j++){
			dp[0][j]=dp[1][j]; //反转dp 
		}
	} 
	cout<<dp[1][n];
	return 0;
} 
```
**解释**  思路大致上和之前的差不多，是需要在每次算完一行的数之后，将第1行的内容迭代到第0行即可，这样就能省略一些空间，数组不用开那么大。
***优化方法2***：原地优化
*思路方法：* 此方法是在方法1的基础上再进行的优化，只需要使用一行数组就能够实现
*代码实现：*
```cpp
//完全背包：整数拆分
#include<bits/stdc++.h>
using namespace std;
long long dp[10000]={0};
int main(){
	int n;
	cin>>n; //求dp(n，n) 
	dp[0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=n;j++){
			if(i<=j) dp[j]=dp[j]+dp[j-i];
			else dp[j]=dp[j]; 
		}
	}
	cout<<dp[n]; 
	return 0;
} 
```
**解释：** 从代码量可以看到此方法明显轻松，但想要理解这个方法需要先理解前面两种方法，*原理* ：本质上我们求解一个数其实只需要两个数。第一个是同行中的某个数，另一个是同列中的上一个数，因此我们可以做一下思考：当我们要求解第i行第j个数的时候，我们可以把第i行分为两个部分，第一个部分是第j个数之前的部分，根据我们的求解思路，第一个部分的值都已经算完了，第二个部分是j以及j时候的数，其结果没有计算，如果我们把所有结果压缩到一行，我们会发现第一个部分我们已经求解了，我们需要的第一个值就在这些求解的值里面，第二个值就是我们现在这个位置但还没有求解的值，因此我们就能算出我们想要的这个值，再将这个值和原来这个位置的值替换，以此类推，就完成了对于值的迭代。最终就能算出我们想要的答案。
***本质：*** 动态规划本质是对集合的划分和映射，这样的划分和映射需要靠经验和积累。

**变式：** 01背包问题，在上题的基础上增加的，每个数不能重复。
*代码实现*（优化方案2）
```cpp
//01背包：整数拆分
#include<bits/stdc++.h>
using namespace std;
long long dp[10000];
int main(){
	int n;
	cin>>n;
	dp[0]=1;
	for(int i=1;i<=n;i++){
		for(int j=n;j>=0;j--){
			if(j>=i) dp[j]=dp[j-i]+dp[j];
			else dp[j]=dp[j];
		}
	}
	cout<<dp[n];
	return 0;
} 
```
*思路解析：* 整体框架与完全背包基本相同，但不同的是映射关系，
dp(i，j)=dp(i-1，j)+dp(i-1，j-1) 基本解题思路就略过了，主要说一下如何原地优化，可以发现，第i行的内容主要与第i-1行有关，如果使用完全背包的思路会发现第i-1行有的数会被覆盖，因此我们可以倒序计算，因为每个数之和他之前的数有关，倒着计算就不会覆盖计算某个数前面其需要的那个数字，如此就完成了原地优化。
**因此** 我们可以知道，完全背包需要正序原地优化，01背包需要倒序优化。