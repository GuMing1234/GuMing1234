## 快速幂介绍：
* 快速幂是一种高效计算大数幂次的算法，时间复杂度为log（n）
* 主要运用原理：将指数进行二进制分解。
*代码实现：*
```cpp
int pow_mul(int x,int n){ //求x的n次幂
	int ans=1;
	while(n){ //当n不为0的时候不断循环
		if(n&1){ //通过按位与操作，判断n的个位时否是1，如果是以就要把他当作结果成进去
			ans*=x; //如果n的这一位是1，那么就要将其二进制这一位乘进去
		} //如 10 可以被分解为：2^3+2^1,这就是二进制得到的 1010 ，每当有一个1是，就把当前的             指数乘进去
		x*=x; //每进行一波操作，无论是否当前进行了乘积操作，都把指数上升一位
		n >>=1;  //右移操作，相当于 /2 ，最高位会填充 0。
	}
	return ans; //返回答案。
}
```
## 矩阵乘法介绍：
* 主要运用对一种一种线性变换找到一种规律，运用矩阵相乘的方法找到这种状态转移。
## 矩阵快速幂运用
*以斐波那契数列为例：*
```cpp
对于下面这个数列
1 1 2 3 5 8 ······
我们可以假设有一个第0项 找到所有的项的一个符合的规律
0 1 1 2 3 5 8
```
$$
\begin{bmatrix}
a & b \\
c & d
\end{bmatrix}
$$
假设有一个这样的矩阵，我们这个矩阵代表每次转换的规律，上一次矩阵乘我们的矩阵可以得到下一个矩阵。
```cpp
0 1 1 2 3
---
  ---
    ---
      ---
```
$\begin{bmatrix} 0 \ 1 \\ 1 \ 1 \end{bmatrix}$ -> $\begin{bmatrix} 1 \ 1 \\ 1 \ 2 \end{bmatrix}$  -> $\begin{bmatrix} 1 \ 2 \\ 2 \ 3 \end{bmatrix}$  
第一个矩阵乘上我们上面的默认矩阵就可以得到下一个矩阵。我们可以用解方程的方法来得到。
解的方程为 a=0，b =1，c=1，d =1
即 $\begin{bmatrix} 0 \ 1 \\ 1 \ 1 \end{bmatrix}$ 然后我们就可以得到下一个矩阵。
**单位矩阵：** 即一个主对角线全是1，其余位置上全是0，的一个矩阵。在这个里面矩阵快速幂里面，我们的res初始值就是单位矩阵。

**以斐波那契数列来实现一下：**
[P1962 斐波那契数列 - 洛谷](https://www.luogu.com.cn/problem/P1962#ide)
*代码实现：*
```cpp
#include<bits/stdc++.h>
using namespace std; //矩阵快速幂
const long long mod = 1000000007;
using matrix = vector<vector<long long>>;  //将vector<vector<long long>>名为matrix                                              意为矩阵
matrix double2(matrix A,matrix B){
    matrix res(2,vector<long long>(2));    //基于斐波那契数列的矩阵相乘
    res[0][0]=(A[0][0]*B[0][0]+A[0][1]*B[1][0])%mod; //矩阵相乘规则
    res[1][0]=(A[1][0]*B[0][0]+A[1][1]*B[1][0])%mod;
    res[0][1]=(A[0][0]*B[0][1]+A[0][1]*B[1][1])%mod;
    res[1][1]=(A[1][0]*B[0][1]+A[1][1]*B[1][1])%mod;
    return res;
}
long long pow_mul(long long n){
    matrix res={{1,0},{0,1}};  //单位矩阵
    matrix base={{0,1},{1,1}};  //基础矩阵
    while(n){  //快速幂部分
        if(n & 1){ 
            res=double2(res,base);  //将基础矩阵和结果矩阵相乘
        }
        base=double2(base,base);  //单位矩阵自乘代表二进制位加1
        n >>=1;
    }
    return res[0][1];  //返回结果 
}
int main(){
    long long n;
    cin>>n;
    long long res=pow_mul(n);
    cout<<res<<endl;
    return 0;
}
```

### 例题：
**在一次校际学术交流活动中，两个学院的代表：小蓝与小桥，被安排一同前往主会场。
主会场与校门口之间有一条笔直的林荫大道。两人从校门口同时出发，沿着这条路向前行进。
为了体现两院之间“并肩同行、友好互助”的精神，组织方设定了两项特别的规定：
- **每次，他们中只能有一人向前迈出 1 米，另一人则在原地等待，保持协调与平衡。**
- **两人之间的距离始终不得超过 2 米。**
**从校门口到主会场，总共有 N 米。当两人都抵达主会场时，行程即告结束。现在，请你计算在满足上述条件的前提下，小蓝与小桥共有多少种不同的行进方式？由于答案可能很大，你只需给出其对 1e10+7 取余后的结果即可。**
*代码实现：*
```cpp
#include <bits/stdc++.h>
using namespace std;
using matrix=vector<vector<long long>>;
const long long mod=1000000007;
matrix mul(matrix A ,matrix B){  //进行矩阵运算
  matrix res(5,vector<long long>(5,0)); //初始化一个5*5的0矩阵
  for(int i=0;i<5;i++){ //双层for循环来给结果赋值
    for(int j=0;j<5;j++){
      for(int k=0;k<5;k++){
        res[i][j]=(res[i][j]+A[i][k]*B[k][j])%mod;
      }
    }
  }
  return res;
}
long long movie(long long n){
  matrix base={
    {0,1,0,0,0},   //构建基础矩阵  我们假设v0=（0，0，1，0，0），假设这个矩阵对应意义为
	{1,0,1,0,0},   //                    d= -2,-1,0, 1, 2  下标对应两个人之间的距离。
    {0,1,0,1,0},   // 以一个人为主，另一个人距离这个人的d为我们刻画的量。
    {0,0,1,0,1},   //我们这个基础矩阵为每次变化的量，d=-2 的位置只能有d=-1，是来达成
	{0,0,0,1,0},   // 其余同理，构建成这个矩阵，根据矩阵的原理，我们这个原始矩阵乘这个基础阵
  };               //阵就能得到下一步可能的分布。最后就能得到所有的分布情况，取2n步后，d=0的数量
 //但此题由于原始矩阵的特殊性，我们最终结果与基础矩阵*2n后最终间的数相等。
  matrix res={  //构建单位矩阵
    {1,0,0,0,0},
    {0,1,0,0,0},
    {0,0,1,0,0},
    {0,0,0,1,0},
    {0,0,0,0,1},
  };
  while(n){  // 快速幂计算矩阵乘积
    if(n&1){
      res=mul(res,base);
    }
    base=mul(base,base);
    n>>=1;
  }
  return res[2][2]; //取中间的数。
}
int main()
{
  int T;
  cin>>T;
  for(int t=0;t<T;t++){
    long long n;
    cin>>n;
    long long res=movie(2*n); //一共计算2*n步
    cout<<res<<"\n";
  }
  return 0;
}
```
