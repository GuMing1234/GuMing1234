## 基础知识：
***介绍***  高精度是用来实现c++里面数字过大的情况的，数字的位数太大时，我们用高精度可以实现加减乘除的操作。

## 不同类型的模板(推荐)
#### 加法：
用整数来储存数字，是最高效的方法
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int a[2000] = {0}, b[2000] = {0}, c[4000] = {0};
    string num1, num2;
    cin >> num1 >> num2;
    int len1 = num1.size();
    int len2 = num2.size();
    int maxLen = len1 + len2; // 乘积的最大可能位数
    
    // 将字符串反转存储到数组a和b中（低位在前）
    for (int i = len1 - 1, j = 0; i >= 0; i--, j++) {
        a[j] = num1[i] - '0';
    }
    for (int i = len2 - 1, j = 0; i >= 0; i--, j++) {
        b[j] = num2[i] - '0';
    }
    
    // 进行乘法计算
    for (int i = 0; i < len1; i++) {
        for (int j = 0; j < len2; j++) {
            c[i + j] += a[i] * b[j];
        }
    }
    // 处理进位
    for (int i = 0; i < maxLen; i++) {
        if (c[i] >= 10) {
            c[i + 1] += c[i] / 10;
            c[i] %= 10;
        }
    }
    // 找到最高位非零的位置
    int highIndex = maxLen;
    while (highIndex > 0 && c[highIndex] == 0) {
        highIndex--;
    }
    
    // 输出结果（从高位到低位）
    for (int i = highIndex; i >= 0; i--) {
        cout << c[i];
    }
    cout << endl;
    return 0;
}
```
加法较为简单就不过多解释了
#### 减法：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	string num1;
	string num2;
	cin>>num1>>num2; 
	int a[5005]={0};
	int b[5005]={0};
	int c[5005]={0};
	a[0]=num1.size();
	b[0]=num2.size();
	c[0]=a[0];
	for(int i=1;i<=a[0];i++) a[i]=num1[a[0]-i]-'0';
	for(int i=1;i<=b[0];i++) b[i]=num2[b[0]-i]-'0';
	for(int i=1;i<=a[0];i++){
		if(a[i]<b[i]){
			a[i]+=10;
			a[i+1]--;
		}
		c[i]=a[i]-b[i];
	}
	while(c[c[0]]==0) c[0]--;
	for(int i=c[0];i>=1;i--) cout<<c[i];
	return 0;
}
```
减法主要要处理如何借位。
#### 乘法：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	string num1,num2;
	cin>>num1>>num2;
	int a[5005];
	int b[5005];
	int c[10010]; 
	a[0]=num1.size();
	b[0]=num2.size();
	c[0]=a[0]+b[0];
	for(int i=1;i<=a[0];i++) a[i]=num1[a[0]-i]-'0';
	for(int i=1;i<=b[0];i++) b[i]=num2[b[0]-i]-'0';
	for(int i=1;i<=a[0];i++){
		for(int j=1;j<=b[0];j++) c[i+j-1]+=a[i]*b[j];
	}
	for(int i=1;i<=c[0];i++){
		if(c[i]>=10){
			c[i+1]+=c[i]/10;
			c[i]%=10;
		}
	}
	while(c[0]>0&&c[c[0]]==0) c[0]--;
	if(c[0]==0) cout<<0;
	for(int i=c[0];i>=1;i--) cout<<c[i];
	return 0;
}
```
**详解：** 
- 高精度乘法主要运用了贡献思路，将第i位和第j位数字的乘积贡献到第i+j-1位。
#### 除法：
*高精度除以高精度：*
```cpp
#include<bits/stdc++.h>
using namespace std;

void subs(int x[],int y[]){
//用来进行两个数的减法运算
	for(int i=x[0];i>=1;i--){
		if(x[i]<y[i]){
			x[i]=x[i]+10;
			x[i-1]=x[i-1]-1;
		}
		x[i]-=y[i];
	}
}

bool comp(int x[],int y[]){
//用来进行同位数的比较大小
	for(int i=1;i<=x[0];i++){
		if(x[i]>y[i]) return true;
		if(x[i]<y[i]) return false;
	}
	return true;
}

void cpy(int x[],int y[],int offset){
//用来将一个数组加上偏移量，复制到另一个数组。
	for(int i=1;i<=x[0];i++){
		y[i+offset]=x[i];
	}
	y[0]=x[0]+offset;
}
int main(){
	string num1;
	string num2;
	cin>>num1>>num2; 
	int a[5005];
	int b[5005];
	int c[5005];
	a[0]=num1.size();
	b[0]=num2.size();
	c[0]=a[0]-b[0]+1;
	for(int i=1;i<=a[0];i++) a[i]=num1[i-1]-'0';
	for(int i=1;i<=b[0];i++) b[i]=num2[i-1]-'0';
	int t[10002];
	for(int i=1;i<=c[0];i++){
		memset(t,0,sizeof(t));
		cpy(b,t,i-1);
		a[0]=t[0];
		while(comp(a,t)){
			subs(a,t);
			c[i]++;
		}
	}
	if(c[1]!=0){
		for(int i=1;i<=c[0];i++) cout<<c[i];
	}
	else{
		for(int i=2;i<=c[0];i++) cout<<c[i];
	}
	return 0;
}
```
**详解：**
- 代码较长需要详细解释一下（主要是除法部分）。
- 详细参考[【从0开始的C++算法课】第08期 | 高精度数除以高精度数｜高精度运算 & 高精度除法运算(下) | 大数除法原理以及代码实现_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1TMrNYMEpS/?spm_id_from=333.337.search-card.all.click&vd_source=47f23df979124805432636f780cc9684)
1. 在这个代码里面，我们每个数组的第一位，都代表这个数组的有效位数。
2. c表示商，商的位数只有可能为a[0]-b[0]+1。因此最后只有可能有一个前导0。
3. 我们进行一次除法都要将位数后移以为，因此我们将b数组复制到t数组里面的时候，就会带上这个偏移量，最后和a进行除法的是t。
4. 为了保证每次和t相除的时候，a是和t对齐的，因此要将a的有效位数赋为和t相同。
5. 而a前面的数字，在我们除的过程中就被减掉了，因此在这个除法里面，b数组自始至终都没有变，a数组作为一个主要相除的地方，不断被减。
6. 当我们t数组小于a数组的时候，我们就将c数组的对应位置加1，来模拟我们的除法过程。
