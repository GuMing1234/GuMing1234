# 基本概念
1. **运用对半砍的方式来做到高效的寻找数字**
2. **只能运用于有序的数组**.
***易错点：*** 
 - 对于while（）里面的条件判断不清楚
 - 对于mid是否减一不清楚(mid=(left+right)/2);
*方法：* 对于易错点的解决方法，我们首先要确定我们的区间到底是双闭还是左闭右开。
*详解：* 
- 首先对于双闭的方法，while（left<=right）,原因:对于双闭的情况，我们这时候区间里有只有一个元素，这时候我们要进行查找，因此我们就要去找这个元素，因此left=right是合法区间，因此条件为<=,对于mid， if(a[mid]>target) right=mid-1;因为我们的区间不能包含mid，因此要减一。
***标准二分查找：***
```cpp
//伪代码
int left=0,right=n-1;
    int result=-1;
    while(left<=right){
        int mid=(right+left)/2;
        if(a[mid]>=k){
            if(a[mid]==k) result=mid;
            right=mid-1;
        } 
        else left=mid+1;
    }
```
*解释：* 在这个标准过程中，我们可以找到符合目标数字k的最小序列大小，同理，如果我们想要得到最大序列大小，我们可以把等于的部分放到else的部分。
### 例题一 砍树
[P1873 [COCI 2011/2012 #5] EKO / 砍树 - 洛谷](https://www.luogu.com.cn/problem/P1873#ide) 
**导引：** 本题主要是对二分查找的应用，来减少循环次数。
*代码实现：*
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[1000005];
long long sum(int k){
    int len=0;
    while(k>=a[len]) len++;
    long long num=0;
    for(int i=len;i<n;i++) num+=(a[i]-k);
    return num;
}
int main(){
    cin>>n>>m;
    int h;
    for(int i=0;i<n;i++) cin>>a[i];
    sort(a,a+n);
    int left=0,right=a[n-1];
    while(left<=right){
        int mid=(right+left)/2;
        if(sum(mid)>=m){
            if(sum(mid)>=m) h=mid;
            left=mid+1;
        }
        else right=mid-1;
    }
    cout<<h;
    return 0;
}
```

**解析：** 
- 此题中我们对于二分查找的应用在于对高度的寻找，对于的高度是否符合的判断封装在函数里面
- 通过这样的方式我们可以高效的找到我们需要的高度，而时间主要花在判断是否是符合的高度，根据题目描述我们对高度判断是否符合不会超过太多。因此方法可行。
## 二分答案
**解释：** 正如名字所言，二分答案就是答案进行二分法
*二分答案使用条件：*
1. 首先我们要能够预估出答案的取值范围，在此范围里面我们取二分答案。
2. 其次，我们的答案必须要与题干条件有单调性，不然查找无用，就想二分查找必须要在有序的数组里面找一样。
### 例题一：跳石头
[P2678 [NOIP 2015 提高组] 跳石头 - 洛谷](https://www.luogu.com.cn/problem/P2678#ide)
*代码实现：*
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[50005];
int main(){
    int l,n,m,now,before=0;
    cin>>l>>n>>m;
    for(int i=0;i<n;i++){
        cin>>now;
        a[i]=now-before;
        before=now;
    }
    a[n]=l-before;
    if(n==m){
        cout<<l;
        return 0;
    }
    int left=1,right=l/(n-m);
    while(left<=right){
        int mid=(left+right)/2,k=0,tem;
        for(int i=0;i<=n;i++){
            tem=a[i];
            while(tem<mid&&i<=n){
                i++;
                tem+=a[i];
                k++;
            }
        }
        if(k<=m) left=mid+1;
        else right=mid-1;
    }
    cout<<right;
    return 0;
}
```
**解析：** 
1. 在此题里面，第一个条件，预估答案范围，一共n个石头，移走了m个，因此最理想的情况就是l最小长度的最大值就是 l /(n-m) ,这就是最大的答案，最小的答案肯定是1 。
2. 我们此题的思路是，先划定一个最小长度的值，然后遍历整个长度空间，如果小于这个最小长度，就让他和他的下一个合并，最后数一下合并的次数，记作 k。
3. 第二个条件，如果我们划分的最小长度比较小，那么合并的次数就比较小，因此k将小于我们的最大合并值m ，因此我们就能找到单调性，根据k与m的关系我们来调整 left 与 right 的大小，来二分查找答案。
4. 这里面有一个注意的点，就是我们最后取那个值作为答案，我们在这个二分答案的设置里面，left是用来试探的，因为我们要找最大值，因此在相同的值里面我们要去找最大的那个值，因此要往右找left，来作为试探值，而right就是用来逼近的值，也就是准确值，最后我们输出的也是right，用来当做答案。
**发现：** 我们在代码里面的解方程通常就是用二分答案来解决的
易错：我们在进行分析的时候，一定要搞清楚单调性的条件，看什么时候将left赋为mid