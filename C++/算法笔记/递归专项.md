# 基础练习
递归的三大底层条件
1. 能够将一个复杂问题分解为多个更简单的问题，这是我们分析时的核心
2. 子问题的求解方式和原问题相同
3. 有终止条件
这三个条件却一不可，否则将会出错，或无限迭代

### 例题一：选数
[P1036 [NOIP 2002 普及组] 选数 - 洛谷](https://www.luogu.com.cn/problem/P1036#ide)
``` cpp
#include<bits/stdc++.h>
using namespace std;
int a[30];
int ans[10000];
int n,k;
int res;
bool is_prime(int a)
{
    if(a<2) return false;
    for(int i=2;i<=sqrt(a);i++){
        if(a%i==0) return false;
    }
    return true;
}
void f(int flag,int num,int sum ){
    if(num==0){
        if(is_prime(sum)){ans[res]=sum;res++;}
    }
    if(n-flag<num) return;
    for(int i=flag;i<n;i++){
        f(i+1,num-1,sum+a[i]);
    }
    return;
}
int main()
{
    cin>>n>>k;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    f(0,k,0);
    
    cout<<res;
    return 0;
}
```
*解析此题*：
1，首先我们要用递归来模拟选数的过程，将问题进行拆分
**思路：** 我们要在n个数里面找到k个数，根据三大原则，要将问题进行拆分，先想一个f函数
f，能够在n个数里面找到k个数，如果我们选了一个数，那么我们就要在剩下的n-1个数里面找k-1个数，这样我们就完成了对问题的拆分；
1. f(0,k,sum)  从第零个数开始找，找到第n个数
2. f(1,k-1,sum+a[i]) 从第一个数开始 ，找到第n个数
3. 以次类推
我们默认内层能找到结果
*接下来设置递归出口* ：当k个数都找完的时候，这是对sum进行判断，如果是质数，那么将次方法录入，最后输出即可
我们这里面的层递归里面都有个循环，用来模拟，第x个数选择哪一个数字

### 例题二：深度优先搜索(dfs)
#### dfs框架
```cpp 
void dfs(int step){
	if(到达目的地){
		输出解
		返回
	}
	合理的剪枝操作
	for(int i=1;i<=枚举数；i++){
	if(满足条件){
		更新状态位
		dfs(step+1);
		恢复状态位
		}
	}
	return;
}
```
*本质上dfs使用了递归的方法来实现枚举所有情况*
#### 例题
[P1157 组合的输出 - 洛谷](https://www.luogu.com.cn/problem/P1157)
**本体就是使用了深度优先搜索的方法来枚举所有情况**
代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[25];
void dfs(int step,int flag)
{
    if(step==k){
        for(int i=0;i<k;i++){
            cout<<setw(3)<<a[i];
        }
        cout<<endl;
    }
    if(n-flag<k-step) return;
    for(int i=flag+1;i<=n;i++){
        a[step]=i;
        dfs(step+1,i);
    }
    return ;
}

int main()
{
    cin>>n>>k;  
    dfs(0,0);
    return 0;
}
```
**解析一下此代码**
1. 首先此题我们要找到所有的方法，因此用深度优先搜索，可以找到所有的情况
2. 接下来根据框架设置dfs函数，经分析，此题的情况为排列1到n 的所有数
3. step在此题中显然就是选的数字是否到达k，因此初始为0，
4. 还要有一个数组来储存我们选到的数字，因此用a来储存
5. 每次到达k处时我们都要进行一边输出
6. 同时选数的时候我们的下一个数必须得在上一个的后面，因此需要一个数来记录我们上一个选的数是什么，用flag来表示，同时传入参数中，跟随dfs动态变化
7. 我们还需要一个剪枝操作，来减少负担，如果剩下的数小于我们还需要选的数，肯定不成立。
至此代码分析完毕

