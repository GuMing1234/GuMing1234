# 博客链接

**链接：** 
# 题目一：链表相交

**题目链接：** [链表相交_牛客题霸_牛客网](https://www.nowcoder.com/practice/bd911c77a1ed4e289a0699fa7df23b6c?tpId=383&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj) 

**方法：** 参考别人的精妙方法，我写了这个双指针高效解决这道题
1. 首先我们定义两个指针分别指向两个链表的头结点，之后两个指针一起往后遍历，终止条件为两指针指向同一个节点。
2. 一旦A指针指向`nullptr`，就将其指向B链表的头结点，B同理，若两链表有交点，那么最后两指针一定指向了交点处，若没有交点，最后一定指向了空指针。
3. **为什么这样可行：** 
	1. 首先假设A链表相交前的长度为a，B前面为b，共享的部分为c。
	2. 如果有交点，且`a=b`的话，两个指针在交点处就相等了，如果没有交点，最后两指针都移动了`a+b+2c`的长度，最后同时指向了`nullptr` 。
	3. 如果有交点，且`a!=b` ,那么两个指针会移动`a+b+c` 的长度，最终在交点处相交。

*代码实现：*
```cpp
#include <bits/stdc++.h>
using namespace std;

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}
};  
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    if(headA==nullptr||headB==nullptr) return nullptr;
    ListNode *pA=headA,*pB=headB;
    while(pA!=pB){
        if(pA!=nullptr) pA=pA->next;
        else pA=headB;
        if(pB!=nullptr) pB=pB->next;
        else pB=headA;
    }
    return pA;
}
```

# 题目二：插队

**题目链接：** [插队_牛客题霸_牛客网](https://www.nowcoder.com/practice/ed27560740114f07a23fad98afac12b6?tpId=383&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=%2Fexam%2Foj) 

**方法：** 
1. 首先我们先分析一下这个题，我们要做的操作是首先将n个人先组成一个链表，之后，我们进行m次操作，每次找到`x` 和`y` 的指针位置，然后进行链表的删除和插入操作。
2. 不难发现，如果我们在找`x`和`y`的位置的时候，如果一个一个找时间复杂度就到了O(n * m)，如果因为查询导致增加n的复杂度，通常是难以接受的，一次我们需要用别的方法来查询。
3. 为了查询便捷我们使用哈希表，里面`key`设置为名字，`value` 设置为对应名字的指针的前驱，为什么是前驱呢？因为我们如果想进行插入删除操作，必须要知道x前一个节点的指针，而我们使用的是单向链表，所以要找`x`的前驱，`y`同理，之后我们用哈希表来查询就可以把时间复杂度缩短到O(m)。
*代码实现：* 
```cpp
#include <bits/stdc++.h>
using namespace std;

struct person{
    string name;
    person* next;
    person(string b):name(b),next(nullptr){}
};

int main() {
    int n,m;
    cin>>n>>m;
    person* head= new person("");  //创造虚拟头结点
    person* p=head;
    unordered_map<string,person*> hash;
    for(int i=0;i<n;i++){
        string str;
        cin>>str;
        p->next=new person(str);
        hash[str]=p; //hash里面存对应字符串前面的节点。
        p=p->next;
    }
    for(int i=0;i<m;i++){
        string x,y;
        cin>>x>>y;
        person *p1=hash[x];
        person *p2=hash[y];
        if(p2->name==x) continue;//跳过本来x就在y前面的情况
        if(p1->next->next) hash[p1->next->next->name]=p1; //判断后更新x节点后驱的前节点
        person* tem=p1->next; //现将x节点的指针存起来        
        p1->next=p1->next->next; //删除x节点
        tem->next=p2->next; //将x节点与y节点连起来
        p2->next=tem; //将x与y节点之前的前驱连起来
        hash[x]=p2; //更新x的前驱
        hash[y]=tem; //更新y节点的前驱
    }
    person* newhead=head->next;
    while(newhead){
        cout<<newhead->name<<" ";
        newhead=newhead->next;
    }
    return 0;
}
```